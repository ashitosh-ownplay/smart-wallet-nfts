const __vite__fileDeps=["assets/index-CpPiVb-1.js","assets/index-B_SY1GJM.css","assets/checkContractWalletSignature-DIWgZ1UB.js","assets/isValidSignature-Bkter_eL.js","assets/checkContractWalletSignedTypedData-6byDpHKK.js"],__vite__mapDeps=i=>i.map(i=>__vite__fileDeps[i]);
import{t as W,i as re,a as ie,b as D,A as oe,c as ce,f as z,d as Y,D as Z,e as q,g as ue,P as de,h as E,s as pe,B as le,j as F,k as me,l as fe,m as ye,p as ge,u as he,n as L,r as b,o as ve,q as J,v as we,w as h,x as Ae,y as K,z as be,E as G,C as xe,F as X,G as Q,H as Pe,I as w,M as Te,J as ee,K as _e,L as C,N as Ge,O as De,Q as Ee,R as Oe,S as Ie,T as Le,U as T,V as S,W as Ce,_ as v,X as te,Y as Ue,Z as Me,$ as B}from"./index-CpPiVb-1.js";const U=W;function Fe(e){const{abi:t,args:n=[],name:a}=e,s=re(a,{strict:!1}),i=t.filter(o=>s?o.type==="function"?ie(o)===a:o.type==="event"?U(o)===a:!1:"name"in o&&o.name===a);if(i.length===0)return;if(i.length===1)return i[0];let r;for(const o of i){if(!("inputs"in o))continue;if(!n||n.length===0){if(!o.inputs||o.inputs.length===0)return o;continue}if(!o.inputs||o.inputs.length===0||o.inputs.length!==n.length)continue;if(n.every((u,p)=>{const l="inputs"in o&&o.inputs[p];return l?O(u,l):!1})){if(r&&"inputs"in r&&r.inputs){const u=ne(o.inputs,r.inputs,n);if(u)throw new oe({abiItem:o,type:u[0]},{abiItem:r,type:u[1]})}r=o}}return r||i[0]}function O(e,t){const n=typeof e,a=t.type;switch(a){case"address":return D(e,{strict:!1});case"bool":return n==="boolean";case"function":return n==="string";case"string":return n==="string";default:return a==="tuple"&&"components"in t?Object.values(t.components).every((s,i)=>O(Object.values(e)[i],s)):/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(a)?n==="number"||n==="bigint":/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(a)?n==="string"||e instanceof Uint8Array:/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(a)?Array.isArray(e)&&e.every(s=>O(s,{...t,type:a.replace(/(\[[0-9]{0,}\])$/,"")})):!1}}function ne(e,t,n){for(const a in e){const s=e[a],i=t[a];if(s.type==="tuple"&&i.type==="tuple"&&"components"in s&&"components"in i)return ne(s.components,i.components,n[a]);const r=[s.type,i.type];if(r.includes("address")&&r.includes("bytes20")?!0:r.includes("address")&&r.includes("string")?D(n[a],{strict:!1}):r.includes("address")&&r.includes("bytes")?D(n[a],{strict:!1}):!1)return r}}const H="/docs/contract/decodeEventLog";function Se(e){const{abi:t,data:n,strict:a,topics:s}=e,i=a??!0,[r,...o]=s;if(!r)throw new ce({docsPath:H});const c=t.find(m=>m.type==="event"&&r===U(z(m)));if(!(c&&"name"in c)||c.type!=="event")throw new Y(r,{docsPath:H});const{name:u,inputs:p}=c,l=p==null?void 0:p.some(m=>!("name"in m&&m.name));let d=l?[]:{};const y=p.filter(m=>"indexed"in m&&m.indexed);for(let m=0;m<y.length;m++){const g=y[m],P=o[m];if(!P)throw new Z({abiItem:c,param:g});d[l?m:g.name||m]=Be({param:g,value:P})}const f=p.filter(m=>!("indexed"in m&&m.indexed));if(f.length>0){if(n&&n!=="0x")try{const m=q(f,n);if(m)if(l)d=[...d,...m];else for(let g=0;g<f.length;g++)d[f[g].name]=m[g]}catch(m){if(i)throw m instanceof ue||m instanceof de?new E({abiItem:c,data:n,params:f,size:pe(n)}):m}else if(i)throw new E({abiItem:c,data:"0x",params:f,size:0})}return{eventName:u,args:Object.values(d).length>0?d:void 0}}function Be({param:e,value:t}){return e.type==="string"||e.type==="bytes"||e.type==="tuple"||e.type.match(/^(.*)\[(\d+)?\]$/)?t:(q([e],t)||[])[0]}class He extends le{constructor(t){super(`Filter type "${t}" is not supported.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"FilterTypeNotSupportedError"})}}const R="/docs/contract/encodeEventTopics";function Re(e){var c;const{abi:t,eventName:n,args:a}=e;let s=t[0];if(n){const u=Fe({abi:t,name:n});if(!u)throw new F(n,{docsPath:R});s=u}if(s.type!=="event")throw new F(void 0,{docsPath:R});const i=z(s),r=U(i);let o=[];if(a&&"inputs"in s){const u=(c=s.inputs)==null?void 0:c.filter(l=>"indexed"in l&&l.indexed),p=Array.isArray(a)?a:Object.values(a).length>0?(u==null?void 0:u.map(l=>a[l.name]))??[]:[];p.length>0&&(o=(u==null?void 0:u.map((l,d)=>Array.isArray(p[d])?p[d].map((y,f)=>V({param:l,value:p[d][f]})):p[d]?V({param:l,value:p[d]}):null))??[])}return[r,...o]}function V({param:e,value:t}){if(e.type==="string"||e.type==="bytes")return me(fe(t));if(e.type==="tuple"||e.type.match(/^(.*)\[(\d+)?\]$/))throw new He(e.type);return ye([e],[t])}function Ve({abi:e,eventName:t,logs:n,strict:a=!0}){return n.map(s=>{var i;try{const r=Se({...s,abi:e,strict:a});return t&&!t.includes(r.eventName)?null:{...r,...s}}catch(r){let o,c;if(r instanceof Y)return null;if(r instanceof E||r instanceof Z){if(a)return null;o=r.abiItem.name,c=(i=r.abiItem.inputs)==null?void 0:i.some(u=>!("name"in u&&u.name))}return{...s,args:c?[]:{},eventName:o}}}).filter(Boolean)}function $e(e){return!!(e&&typeof e=="object"&&"type"in e&&e.type==="event")}function Ne(e){const{signature:t}=e;let n;return $e(t)?n=t:n=ge(t),{abiEvent:n,hash:W(n),topics:Re({abi:[n],args:e.filters})}}function ke(e){const{logs:t,events:n,strict:a}=e;return Ve({logs:t,abi:n.map(s=>s.abiEvent),strict:a})}function je(e){return`0x${e.reduce((t,n)=>t+n.replace("0x",""),"")}`}function _(e){if(["string","number"].includes(typeof e)&&!Number.isInteger(Number(e)))throw new Error(`Expected value to be an integer to convert to a bigint, got ${e} of type ${typeof e}`);return e instanceof Uint8Array?BigInt(he(e)):BigInt(e)}const ae=50000n,We=e=>{const t=ze(e);return{domain:{name:"zkSync",version:"2",chainId:e.chainId},types:{Transaction:[{name:"txType",type:"uint256"},{name:"from",type:"uint256"},{name:"to",type:"uint256"},{name:"gasLimit",type:"uint256"},{name:"gasPerPubdataByteLimit",type:"uint256"},{name:"maxFeePerGas",type:"uint256"},{name:"maxPriorityFeePerGas",type:"uint256"},{name:"paymaster",type:"uint256"},{name:"nonce",type:"uint256"},{name:"value",type:"uint256"},{name:"data",type:"bytes"},{name:"factoryDeps",type:"bytes32[]"},{name:"paymasterInput",type:"bytes"}]},primaryType:"Transaction",message:t}};function ze(e){const{gas:t,nonce:n,to:a,from:s,value:i,maxFeePerGas:r,maxPriorityFeePerGas:o,paymaster:c,paymasterInput:u,gasPerPubdata:p,data:l}=e;return{txType:113n,from:BigInt(s),to:a?BigInt(a):0n,gasLimit:t??0n,gasPerPubdataByteLimit:p??ae,maxFeePerGas:r??0n,maxPriorityFeePerGas:o??0n,paymaster:c?BigInt(c):0n,nonce:n?BigInt(n):0n,value:i??0n,data:l||"0x0",factoryDeps:[],paymasterInput:u||"0x"}}async function Ye(e){const{account:t,eip712Transaction:n,chainId:a}=e,s=We(n),i=await t.signTypedData({...s});return qe({...n,chainId:a,customSignature:i})}async function Ze(e){const{account:t,transaction:n}=e;let[a,s,i,r,o,c,u]=await Promise.all([L(n),b(n.to),b(n.value),b(n.gas),b(n.maxFeePerGas),b(n.maxPriorityFeePerGas),b(n.eip712).then(l=>l==null?void 0:l.gasPerPubdata)]);if(!r||!o||!c){const d=await ve(n)({method:"zks_estimateFee",params:[{from:t.address,to:s,data:a,value:i?J(i):void 0}]});r=_(d.gas_limit),o=_(d.max_fee_per_gas)*2n,c=_(d.max_priority_fee_per_gas)||1n,u=_(d.gas_per_pubdata_limit)}return{...await we({transaction:{...n,gas:r,maxFeePerGas:o,maxPriorityFeePerGas:c},from:t.address}),...n.eip712,gasPerPubdata:u,from:t.address}}function qe(e){const{chainId:t,gas:n,nonce:a,to:s,from:i,value:r,maxFeePerGas:o,maxPriorityFeePerGas:c,customSignature:u,factoryDeps:p,paymaster:l,paymasterInput:d,gasPerPubdata:y,data:f}=e,m=[a?h(a):"0x",c?h(c):"0x",o?h(o):"0x",n?h(n):"0x",s??"0x",r?h(r):"0x",f??"0x0",h(t),h(""),h(""),h(t),i??"0x",y?h(y):h(ae),p??[],u??"0x",l&&d?[l,d]:[]];return je(["0x71",Ae(m)])}function Je(e={}){return Ne({signature:"event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason)",filters:e})}const Ke=()=>{const e=BigInt(Math.floor(Math.random()*4294967296)),t=BigInt(Math.floor(Math.random()*4294967296)),n=BigInt(Math.floor(Math.random()*4294967296)),a=BigInt(Math.floor(Math.random()*4294967296)),s=BigInt(Math.floor(Math.random()*4294967296)),i=BigInt(Math.floor(Math.random()*4294967296));return e<<BigInt(160)|t<<BigInt(128)|n<<BigInt(96)|a<<BigInt(64)|s<<BigInt(32)|i},Xe=()=>BigInt(K([J(Ke()),"0x0000000000000000"]));function M(e){return Object.fromEntries(Object.entries(e).map(([t,n])=>[t,be(n)?n:h(n)]))}function Qe(e){return e.id===324||e.id===300||e.id===302}async function et(e){var t;return x({...e,operation:"eth_sendUserOperation",params:[M(e.userOp),((t=e.options.overrides)==null?void 0:t.entrypointAddress)??G]})}async function $(e){var n;const t=await x({...e,operation:"eth_estimateUserOperationGas",params:[M(e.userOp),((n=e.options.overrides)==null?void 0:n.entrypointAddress)??G]});return{preVerificationGas:w(t.preVerificationGas),verificationGas:w(t.verificationGas),verificationGasLimit:w(t.verificationGasLimit),callGasLimit:w(t.callGasLimit)+Te}}async function tt(e){const t=await x({...e,operation:"thirdweb_getUserOperationGasPrice",params:[]});return{maxPriorityFeePerGas:w(t.maxPriorityFeePerGas),maxFeePerGas:w(t.maxFeePerGas)}}async function nt(e){var n,a;const t=await x({...e,operation:"eth_getUserOperationReceipt",params:[e.userOpHash]});if(t){if(t.success===!1){const i=(a=(n=ke({events:[Je()],logs:t.logs})[0])==null?void 0:n.args)==null?void 0:a.revertReason;if(!i)throw new Error(`UserOp failed at txHash: ${t.transactionHash}`);const r=xe({data:i});throw new Error(`UserOp failed with reason: '${r.args.join(",")}' at txHash: ${t.transactionHash}`)}return t.receipt}}async function at(e){const t=await x({options:e.options,operation:"zk_paymasterData",params:[e.transaction]});return{paymaster:t.paymaster,paymasterInput:t.paymasterInput}}async function st(e){return{transactionHash:(await x({options:e.options,operation:"zk_broadcastTransaction",params:[{...e.transaction,signedTransaction:e.signedTransaction}]})).transactionHash}}async function x(e){var c;const{options:t,operation:n,params:a}=e,s=((c=t.overrides)==null?void 0:c.bundlerUrl)??X(t.chain),r=await Q(t.client)(s,{method:"POST",headers:{"Content-Type":"application/json"},body:Pe({jsonrpc:"2.0",id:1,method:n,params:a})}),o=await r.json();if(!r.ok||o.error){let u=o.error||r.statusText;typeof u=="object"&&(u=JSON.stringify(u));const p=o.code||"UNKNOWN";throw new Error(`${n} error: ${u}
Status: ${r.status}
Code: ${p}`)}return o.result}async function rt(e,t){var s,i,r;if((s=t.overrides)!=null&&s.predictAddress)return t.overrides.predictAddress(e);if((i=t.overrides)!=null&&i.accountAddress)return t.overrides.accountAddress;const n=t.personalAccountAddress;if(!n)throw new Error("Account address is required to predict the smart wallet address.");const a=ee(((r=t.overrides)==null?void 0:r.accountSalt)??"");return _e({contract:e,method:"function getAddress(address, bytes) returns (address)",params:[n,a]})}function it(e){var a,s;const{factoryContract:t,options:n}=e;return(a=n.overrides)!=null&&a.createAccount?n.overrides.createAccount(t):C({contract:t,method:"function createAccount(address, bytes) returns (address)",params:[n.personalAccount.address,ee(((s=n.overrides)==null?void 0:s.accountSalt)??"")]})}function ot(e){var s;const{accountContract:t,options:n,transaction:a}=e;return(s=n.overrides)!=null&&s.execute?n.overrides.execute(t,a):C({contract:t,method:"function execute(address, uint256, bytes)",params:[a.to||"",a.value||0n,a.data||"0x"]})}function ct(e){var s;const{accountContract:t,options:n,transactions:a}=e;return(s=n.overrides)!=null&&s.executeBatch?n.overrides.executeBatch(t,a):C({contract:t,method:"function executeBatch(address[], uint256[], bytes[])",params:[a.map(i=>i.to||""),a.map(i=>i.value||0n),a.map(i=>i.data||"0x")]})}async function N(e){var l,d,y,f;const{userOp:t,options:n}=e;if((l=n.overrides)!=null&&l.paymaster)return(d=n.overrides)==null?void 0:d.paymaster(t);const a={"Content-Type":"application/json"},s=n.client,i=Ge(n.chain),r=((y=n.overrides)==null?void 0:y.entrypointAddress)??G,c=await Q(s)(i,{method:"POST",headers:a,body:JSON.stringify({jsonrpc:"2.0",id:1,method:"pm_sponsorUserOperation",params:[M(t),r]})}),u=await c.json();if(!c.ok){const m=u.error||c.statusText,g=u.code||"UNKNOWN";throw new Error(`Paymaster error: ${m}
Status: ${c.status}
Code: ${g}`)}if(u.result)return typeof u.result=="string"?{paymasterAndData:u.result}:{paymasterAndData:u.result.paymasterAndData,verificationGasLimit:u.result.verificationGasLimit?w(u.result.verificationGasLimit):void 0,preVerificationGas:u.result.preVerificationGas?w(u.result.preVerificationGas):void 0,callGasLimit:u.result.callGasLimit?w(u.result.callGasLimit):void 0};const p=((f=u.error)==null?void 0:f.message)||u.error||c.statusText||"unknown error";throw new Error(`Paymaster error from ${i}: ${p}`)}async function ut(e){var l;const{executeTx:t,options:n}=e,s=await De(n.accountContract)?"0x":await pt(n),i=await L(t);let{maxFeePerGas:r,maxPriorityFeePerGas:o}=t;const c=((l=n.overrides)==null?void 0:l.bundlerUrl)??X(n.chain);if(Ee(c)){const d=await tt({options:n});r=d.maxFeePerGas,o=d.maxPriorityFeePerGas}else{const[d,y]=await Promise.all([b(r),b(o)]);if(d&&y)r=d,o=y;else{const f=await Oe(n.client,n.chain);o=y??f.maxPriorityFeePerGas??0n,r=d??f.maxFeePerGas??0n}}const u=Xe(),p={sender:n.accountContract.address,nonce:u,initCode:s,callData:i,maxFeePerGas:r,maxPriorityFeePerGas:o,callGasLimit:0n,verificationGasLimit:0n,preVerificationGas:0n,paymasterAndData:"0x",signature:Ie};if(n.sponsorGas){const d=await N({userOp:p,options:n}),y=d.paymasterAndData;if(y&&y!=="0x"&&(p.paymasterAndData=y),d.callGasLimit&&d.verificationGasLimit&&d.preVerificationGas)p.callGasLimit=d.callGasLimit,p.verificationGasLimit=d.verificationGasLimit,p.preVerificationGas=d.preVerificationGas;else{const f=await $({userOp:p,options:n});if(p.callGasLimit=f.callGasLimit,p.verificationGasLimit=f.verificationGasLimit,p.preVerificationGas=f.preVerificationGas,y&&y!=="0x"){const m=await N({userOp:p,options:n});m.paymasterAndData&&m.paymasterAndData!=="0x"&&(p.paymasterAndData=m.paymasterAndData)}}}else{const d=await $({userOp:p,options:n});p.callGasLimit=d.callGasLimit,p.verificationGasLimit=d.verificationGasLimit,p.preVerificationGas=d.preVerificationGas}return{...p,signature:"0x"}}async function dt(e){var s;const{userOp:t,options:n}=e,a=lt({userOp:t,entryPoint:((s=n.overrides)==null?void 0:s.entrypointAddress)||G,chainId:n.chain.id});if(n.personalAccount.signMessage){const i=await n.personalAccount.signMessage({message:{raw:Le(a)}});return{...t,signature:i}}throw new Error("signMessage not implemented in signingAccount")}async function pt(e){const{factoryContract:t}=e,n=it({factoryContract:t,options:e});return K([t.address,await L(n)])}function lt(e){const{userOp:t,entryPoint:n,chainId:a}=e,s=T(t.initCode),i=T(t.callData),r=T(t.paymasterAndData),o=S([{type:"address"},{type:"uint256"},{type:"bytes32"},{type:"bytes32"},{type:"uint256"},{type:"uint256"},{type:"uint256"},{type:"uint256"},{type:"uint256"},{type:"bytes32"}],[t.sender,t.nonce,s,i,t.callGasLimit,t.verificationGasLimit,t.preVerificationGas,t.maxFeePerGas,t.maxPriorityFeePerGas,r]),c=S([{type:"bytes32"},{type:"address"},{type:"uint256"}],[T(o),n,BigInt(a)]);return T(c)}function ht(e){return e.id==="smart"}const se=new WeakMap,I=new WeakMap;async function vt(e,t,n){const{personalAccount:a,client:s,chain:i}=t;if(!a)throw new Error("Personal wallet does not have an account");const r=n,o=r.factoryAddress??Ce,c=i??r.chain,u="gasless"in r?r.gasless:r.sponsorGas;if(Qe(c))return[ft({creationOptions:n,connectionOptions:t,chain:c,sponsorGas:u}),c];const p=B({client:s,address:o,chain:c}),l=await rt(p,{personalAccountAddress:a.address,...r}).then(f=>f).catch(f=>{throw new Error(`Failed to get account address with factory contract ${p.address} on chain ID ${c.id}. Are you on the right chain?`,{cause:f})}),d=B({client:s,address:l,chain:c}),y=await mt({...r,chain:c,sponsorGas:u,personalAccount:a,accountContract:d,factoryContract:p,client:s});return se.set(a,e),I.set(e,a),[y,c]}async function wt(e){const t=I.get(e);t&&(se.delete(t),I.delete(e))}async function mt(e){const{accountContract:t}=e,n={address:t.address,async sendTransaction(a){const s=ot({accountContract:t,options:e,transaction:a});return j({executeTx:s,options:e})},async sendBatchTransaction(a){const s=ct({accountContract:t,options:e,transactions:a});return j({executeTx:s,options:e})},async signMessage({message:a}){const[{isContractDeployed:s},{readContract:i},{encodeAbiParameters:r},{hashMessage:o},{checkContractWalletSignature:c}]=await Promise.all([v(()=>import("./index-CpPiVb-1.js").then(f=>f.eS),__vite__mapDeps([0,1])),v(()=>import("./index-CpPiVb-1.js").then(f=>f.eW),__vite__mapDeps([0,1])),v(()=>import("./index-CpPiVb-1.js").then(f=>f.eV),__vite__mapDeps([0,1])),v(()=>import("./index-CpPiVb-1.js").then(f=>f.eT),__vite__mapDeps([0,1])),v(()=>import("./checkContractWalletSignature-DIWgZ1UB.js"),__vite__mapDeps([2,3,0,1]))]);await s(t)||(console.log("Account contract not deployed yet. Deploying account before signing message"),await k({options:e,account:n,accountContract:t}));const p=o(a);let l=!1;try{await i({contract:t,method:"function getMessageHash(bytes32 _hash) public view returns (bytes32)",params:[p]}),l=!0}catch{}let d;if(l){const f=r([{type:"bytes32"}],[p]);d=await e.personalAccount.signTypedData({domain:{name:"Account",version:"1",chainId:e.chain.id,verifyingContract:t.address},primaryType:"AccountMessage",types:{AccountMessage:[{name:"message",type:"bytes"}]},message:{message:f}})}else d=await e.personalAccount.signMessage({message:a});if(await c({contract:t,message:a,signature:d}))return d;throw new Error("Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.")},async signTypedData(a){var m,g,P;const s=te(a),[{isContractDeployed:i},{readContract:r},{encodeAbiParameters:o},{checkContractWalletSignedTypedData:c}]=await Promise.all([v(()=>import("./index-CpPiVb-1.js").then(A=>A.eS),__vite__mapDeps([0,1])),v(()=>import("./index-CpPiVb-1.js").then(A=>A.eW),__vite__mapDeps([0,1])),v(()=>import("./index-CpPiVb-1.js").then(A=>A.eV),__vite__mapDeps([0,1])),v(()=>import("./checkContractWalletSignedTypedData-6byDpHKK.js"),__vite__mapDeps([4,3,0,1]))]);if(((g=(m=s.domain)==null?void 0:m.verifyingContract)==null?void 0:g.toLowerCase())===((P=t.address)==null?void 0:P.toLowerCase()))return e.personalAccount.signTypedData(s);await i(t)||(console.log("Account contract not deployed yet. Deploying account before signing message"),await k({options:e,account:n,accountContract:t}));const l=Ue(s);let d=!1;try{await r({contract:t,method:"function getMessageHash(bytes32 _hash) public view returns (bytes32)",params:[l]}),d=!0}catch{}let y;if(d){const A=o([{type:"bytes32"}],[l]);y=await e.personalAccount.signTypedData({domain:{name:"Account",version:"1",chainId:e.chain.id,verifyingContract:t.address},primaryType:"AccountMessage",types:{AccountMessage:[{name:"message",type:"bytes"}]},message:{message:A}})}else y=await e.personalAccount.signTypedData(s);if(await c({contract:t,data:s,signature:y}))return y;throw new Error("Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.")}};return n}function ft(e){const{creationOptions:t,connectionOptions:n,chain:a}=e,s={address:n.personalAccount.address,async sendTransaction(i){const r={data:i.data,to:i.to??void 0,value:i.value??0n,chain:Me(i.chainId),client:n.client};let o=await Ze({account:s,transaction:r});if(e.sponsorGas){const p=await at({options:{client:n.client,overrides:t.overrides,chain:a},transaction:o});o={...o,...p}}const c=await Ye({account:s,chainId:a.id,eip712Transaction:o});return{transactionHash:(await st({options:{client:n.client,overrides:t.overrides,chain:a},transaction:o,signedTransaction:c})).transactionHash,client:n.client,chain:a}},async signMessage({message:i}){return n.personalAccount.signMessage({message:i})},async signTypedData(i){const r=te(i);return n.personalAccount.signTypedData(r)}};return s}async function k(e){const{options:t,account:n,accountContract:a}=e,[{sendTransaction:s},{prepareTransaction:i}]=await Promise.all([v(()=>import("./index-CpPiVb-1.js").then(c=>c.eX),__vite__mapDeps([0,1])),v(()=>import("./index-CpPiVb-1.js").then(c=>c.eU),__vite__mapDeps([0,1]))]),r=i({client:t.client,chain:t.chain,to:a.address,value:0n,gas:50000n});return await s({transaction:r,account:n})}async function j(e){const{executeTx:t,options:n}=e,a=await ut({executeTx:t,options:n}),s=await dt({options:n,userOp:a}),i=await et({options:n,userOp:s}),r=await yt({options:n,userOpHash:i});return{client:n.client,chain:n.chain,transactionHash:r.transactionHash}}async function yt(e){const{options:t,userOpHash:n}=e,a=12e4,s=1e3,i=Date.now()+a;for(;Date.now()<i;){const r=await nt({options:t,userOpHash:n});if(r)return r;await new Promise(o=>setTimeout(o,s))}throw new Error("Timeout waiting for userOp to be mined")}export{vt as connectSmartWallet,wt as disconnectSmartWallet,ht as isSmartWallet,se as personalAccountToSmartAccountMap};
