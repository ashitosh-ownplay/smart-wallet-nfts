const __vite__fileDeps=["assets/index-B8mjO7EN.js","assets/index-B_SY1GJM.css","assets/checkContractWalletSignature-ieMwbFqd.js","assets/isValidSignature-Cm2w24CZ.js","assets/checkContractWalletSignedTypedData-CiThJyfu.js"],__vite__mapDeps=i=>i.map(i=>__vite__fileDeps[i]);
import{t as N,l as ee,m as te,o as G,A as ne,q as ae,r as j,w as W,D as k,x as z,y as re,P as se,z as E,C as ie,B as oe,E as C,F as ce,G as de,H as ue,I as pe,J,n as le,i as fe,K as me,L as _,N as ye,O as Y,Q as q,R as A,S as he,s as K,T as ge,U as D,V as Ae,W as ve,X as Q,Y as we,Z as U,$ as be,a0 as _e,a1 as Oe,a2 as b,a3 as I,a4 as Ge,_ as g,p as Ee,a5 as xe,a6 as M}from"./index-B8mjO7EN.js";const P=N;function Te(n){const{abi:e,args:t=[],name:a}=n,r=ee(a,{strict:!1}),i=e.filter(o=>r?o.type==="function"?te(o)===a:o.type==="event"?P(o)===a:!1:"name"in o&&o.name===a);if(i.length===0)return;if(i.length===1)return i[0];let s;for(const o of i){if(!("inputs"in o))continue;if(!t||t.length===0){if(!o.inputs||o.inputs.length===0)return o;continue}if(!o.inputs||o.inputs.length===0||o.inputs.length!==t.length)continue;if(t.every((c,p)=>{const m="inputs"in o&&o.inputs[p];return m?x(c,m):!1})){if(s&&"inputs"in s&&s.inputs){const c=X(o.inputs,s.inputs,t);if(c)throw new ne({abiItem:o,type:c[0]},{abiItem:s,type:c[1]})}s=o}}return s||i[0]}function x(n,e){const t=typeof n,a=e.type;switch(a){case"address":return G(n,{strict:!1});case"bool":return t==="boolean";case"function":return t==="string";case"string":return t==="string";default:return a==="tuple"&&"components"in e?Object.values(e.components).every((r,i)=>x(Object.values(n)[i],r)):/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(a)?t==="number"||t==="bigint":/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(a)?t==="string"||n instanceof Uint8Array:/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(a)?Array.isArray(n)&&n.every(r=>x(r,{...e,type:a.replace(/(\[[0-9]{0,}\])$/,"")})):!1}}function X(n,e,t){for(const a in n){const r=n[a],i=e[a];if(r.type==="tuple"&&i.type==="tuple"&&"components"in r&&"components"in i)return X(r.components,i.components,t[a]);const s=[r.type,i.type];if(s.includes("address")&&s.includes("bytes20")?!0:s.includes("address")&&s.includes("string")?G(t[a],{strict:!1}):s.includes("address")&&s.includes("bytes")?G(t[a],{strict:!1}):!1)return s}}const S="/docs/contract/decodeEventLog";function De(n){const{abi:e,data:t,strict:a,topics:r}=n,i=a??!0,[s,...o]=r;if(!s)throw new ae({docsPath:S});const u=e.find(l=>l.type==="event"&&s===P(j(l)));if(!(u&&"name"in u)||u.type!=="event")throw new W(s,{docsPath:S});const{name:c,inputs:p}=u,m=p==null?void 0:p.some(l=>!("name"in l&&l.name));let d=m?[]:{};const y=p.filter(l=>"indexed"in l&&l.indexed);for(let l=0;l<y.length;l++){const h=y[l],w=o[l];if(!w)throw new k({abiItem:u,param:h});d[m?l:h.name||l]=Pe({param:h,value:w})}const f=p.filter(l=>!("indexed"in l&&l.indexed));if(f.length>0){if(t&&t!=="0x")try{const l=z(f,t);if(l)if(m)d=[...d,...l];else for(let h=0;h<f.length;h++)d[f[h].name]=l[h]}catch(l){if(i)throw l instanceof re||l instanceof se?new E({abiItem:u,data:t,params:f,size:ie(t)}):l}else if(i)throw new E({abiItem:u,data:"0x",params:f,size:0})}return{eventName:c,args:Object.values(d).length>0?d:void 0}}function Pe({param:n,value:e}){return n.type==="string"||n.type==="bytes"||n.type==="tuple"||n.type.match(/^(.*)\[(\d+)?\]$/)?e:(z([n],e)||[])[0]}class Le extends oe{constructor(e){super(`Filter type "${e}" is not supported.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"FilterTypeNotSupportedError"})}}const R="/docs/contract/encodeEventTopics";function Ce(n){var u;const{abi:e,eventName:t,args:a}=n;let r=e[0];if(t){const c=Te({abi:e,name:t});if(!c)throw new C(t,{docsPath:R});r=c}if(r.type!=="event")throw new C(void 0,{docsPath:R});const i=j(r),s=P(i);let o=[];if(a&&"inputs"in r){const c=(u=r.inputs)==null?void 0:u.filter(m=>"indexed"in m&&m.indexed),p=Array.isArray(a)?a:Object.values(a).length>0?(c==null?void 0:c.map(m=>a[m.name]))??[]:[];p.length>0&&(o=(c==null?void 0:c.map((m,d)=>Array.isArray(p[d])?p[d].map((y,f)=>V({param:m,value:p[d][f]})):p[d]?V({param:m,value:p[d]}):null))??[])}return[s,...o]}function V({param:n,value:e}){if(n.type==="string"||n.type==="bytes")return ce(de(e));if(n.type==="tuple"||n.type.match(/^(.*)\[(\d+)?\]$/))throw new Le(n.type);return ue([n],[e])}function Ue({abi:n,eventName:e,logs:t,strict:a=!0}){return t.map(r=>{var i;try{const s=De({...r,abi:n,strict:a});return e&&!e.includes(s.eventName)?null:{...s,...r}}catch(s){let o,u;if(s instanceof W)return null;if(s instanceof E||s instanceof k){if(a)return null;o=s.abiItem.name,u=(i=s.abiItem.inputs)==null?void 0:i.some(c=>!("name"in c&&c.name))}return{...r,args:u?[]:{},eventName:o}}}).filter(Boolean)}function Ie(n){return!!(n&&typeof n=="object"&&"type"in n&&n.type==="event")}function Me(n){const{signature:e}=n;let t;return Ie(e)?t=e:t=pe(e),{abiEvent:t,hash:N(t),topics:Ce({abi:[t],args:n.filters})}}function Se(n){const{logs:e,events:t,strict:a}=n;return Ue({logs:e,abi:t.map(r=>r.abiEvent),strict:a})}function Re(n={}){return Me({signature:"event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason)",filters:n})}const Ve=()=>{const n=BigInt(Math.floor(Math.random()*4294967296)),e=BigInt(Math.floor(Math.random()*4294967296)),t=BigInt(Math.floor(Math.random()*4294967296)),a=BigInt(Math.floor(Math.random()*4294967296)),r=BigInt(Math.floor(Math.random()*4294967296)),i=BigInt(Math.floor(Math.random()*4294967296));return n<<BigInt(160)|e<<BigInt(128)|t<<BigInt(96)|a<<BigInt(64)|r<<BigInt(32)|i},He=()=>BigInt(J([le(Ve()),"0x0000000000000000"]));function L(n){return Object.fromEntries(Object.entries(n).map(([e,t])=>[e,fe(t)?t:me(t)]))}async function Be(n){var e;return O({...n,operation:"eth_sendUserOperation",params:[L(n.userOp),((e=n.options.overrides)==null?void 0:e.entrypointAddress)??_]})}async function H(n){var t;const e=await O({...n,operation:"eth_estimateUserOperationGas",params:[L(n.userOp),((t=n.options.overrides)==null?void 0:t.entrypointAddress)??_]});return{preVerificationGas:A(e.preVerificationGas),verificationGas:A(e.verificationGas),verificationGasLimit:A(e.verificationGasLimit),callGasLimit:A(e.callGasLimit)+he}}async function Fe(n){const e=await O({...n,operation:"thirdweb_getUserOperationGasPrice",params:[]});return{maxPriorityFeePerGas:A(e.maxPriorityFeePerGas),maxFeePerGas:A(e.maxFeePerGas)}}async function $e(n){var t,a;const e=await O({...n,operation:"eth_getUserOperationReceipt",params:[n.userOpHash]});if(e){if(e.success===!1){const i=(a=(t=Se({events:[Re()],logs:e.logs})[0])==null?void 0:t.args)==null?void 0:a.revertReason;if(!i)throw new Error(`UserOp failed at txHash: ${e.transactionHash}`);const s=ye({data:i});throw new Error(`UserOp failed with reason: '${s.args.join(",")}' at txHash: ${e.transactionHash}`)}return e.receipt}}async function O(n){var u;const{options:e,operation:t,params:a}=n,r=((u=e.overrides)==null?void 0:u.bundlerUrl)??Y(e.chain),s=await q(e.client)(r,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({jsonrpc:"2.0",id:1,method:t,params:a})}),o=await s.json();if(!s.ok||o.error){let c=o.error||s.statusText;typeof c=="object"&&(c=JSON.stringify(c));const p=o.code||"UNKNOWN";throw new Error(`${t} error: ${c}
Status: ${s.status}
Code: ${p}`)}return o.result}async function Ne(n,e){var r,i,s;if((r=e.overrides)!=null&&r.predictAddress)return e.overrides.predictAddress(n);if((i=e.overrides)!=null&&i.accountAddress)return e.overrides.accountAddress;const t=e.personalAccountAddress;if(!t)throw new Error("Account address is required to predict the smart wallet address.");const a=K(((s=e.overrides)==null?void 0:s.accountSalt)??"");return ge({contract:n,method:"function getAddress(address, bytes) returns (address)",params:[t,a]})}function je(n){var a,r;const{factoryContract:e,options:t}=n;return(a=t.overrides)!=null&&a.createAccount?t.overrides.createAccount(e):D({contract:e,method:"function createAccount(address, bytes) returns (address)",params:[t.personalAccount.address,K(((r=t.overrides)==null?void 0:r.accountSalt)??"")]})}function We(n){var r;const{accountContract:e,options:t,transaction:a}=n;return(r=t.overrides)!=null&&r.execute?t.overrides.execute(e,a):D({contract:e,method:"function execute(address, uint256, bytes)",params:[a.to||"",a.value||0n,a.data||"0x"]})}function ke(n){var r;const{accountContract:e,options:t,transactions:a}=n;return(r=t.overrides)!=null&&r.executeBatch?t.overrides.executeBatch(e,a):D({contract:e,method:"function executeBatch(address[], uint256[], bytes[])",params:[a.map(i=>i.to||""),a.map(i=>i.value||0n),a.map(i=>i.data||"0x")]})}async function B(n){var m,d,y,f;const{userOp:e,options:t}=n;if((m=t.overrides)!=null&&m.paymaster)return(d=t.overrides)==null?void 0:d.paymaster(e);const a={"Content-Type":"application/json"},r=t.client,i=Ae(t.chain),s=((y=t.overrides)==null?void 0:y.entrypointAddress)??_,u=await q(r)(i,{method:"POST",headers:a,body:JSON.stringify({jsonrpc:"2.0",id:1,method:"pm_sponsorUserOperation",params:[L(e),s]})}),c=await u.json();if(!u.ok){const l=c.error||u.statusText,h=c.code||"UNKNOWN";throw new Error(`Paymaster error: ${l}
Status: ${u.status}
Code: ${h}`)}if(c.result)return typeof c.result=="string"?{paymasterAndData:c.result}:{paymasterAndData:c.result.paymasterAndData,verificationGasLimit:c.result.verificationGasLimit?A(c.result.verificationGasLimit):void 0,preVerificationGas:c.result.preVerificationGas?A(c.result.preVerificationGas):void 0,callGasLimit:c.result.callGasLimit?A(c.result.callGasLimit):void 0};const p=((f=c.error)==null?void 0:f.message)||c.error||u.statusText||"unknown error";throw new Error(`Paymaster error from ${i}: ${p}`)}async function ze(n){var m;const{executeTx:e,options:t}=n,r=await ve(t.accountContract)?"0x":await Ye(t),i=await Q(e);let{maxFeePerGas:s,maxPriorityFeePerGas:o}=e;const u=((m=t.overrides)==null?void 0:m.bundlerUrl)??Y(t.chain);if(we(u)){const d=await Fe({options:t});s=d.maxFeePerGas,o=d.maxPriorityFeePerGas}else{const[d,y]=await Promise.all([U(s),U(o)]);if(d&&y)s=d,o=y;else{const f=await be(t.client,t.chain);o=y??f.maxPriorityFeePerGas??0n,s=d??f.maxFeePerGas??0n}}const c=He(),p={sender:t.accountContract.address,nonce:c,initCode:r,callData:i,maxFeePerGas:s,maxPriorityFeePerGas:o,callGasLimit:0n,verificationGasLimit:0n,preVerificationGas:0n,paymasterAndData:"0x",signature:_e};if(t.sponsorGas){const d=await B({userOp:p,options:t}),y=d.paymasterAndData;if(y&&y!=="0x"&&(p.paymasterAndData=y),d.callGasLimit&&d.verificationGasLimit&&d.preVerificationGas)p.callGasLimit=d.callGasLimit,p.verificationGasLimit=d.verificationGasLimit,p.preVerificationGas=d.preVerificationGas;else{const f=await H({userOp:p,options:t});if(p.callGasLimit=f.callGasLimit,p.verificationGasLimit=f.verificationGasLimit,p.preVerificationGas=f.preVerificationGas,y&&y!=="0x"){const l=await B({userOp:p,options:t});l.paymasterAndData&&l.paymasterAndData!=="0x"&&(p.paymasterAndData=l.paymasterAndData)}}}else{const d=await H({userOp:p,options:t});p.callGasLimit=d.callGasLimit,p.verificationGasLimit=d.verificationGasLimit,p.preVerificationGas=d.preVerificationGas}return{...p,signature:"0x"}}async function Je(n){var r;const{userOp:e,options:t}=n,a=qe({userOp:e,entryPoint:((r=t.overrides)==null?void 0:r.entrypointAddress)||_,chainId:t.chain.id});if(t.personalAccount.signMessage){const i=await t.personalAccount.signMessage({message:{raw:Oe(a)}});return{...e,signature:i}}throw new Error("signMessage not implemented in signingAccount")}async function Ye(n){const{factoryContract:e}=n,t=je({factoryContract:e,options:n});return J([e.address,await Q(t)])}function qe(n){const{userOp:e,entryPoint:t,chainId:a}=n,r=b(e.initCode),i=b(e.callData),s=b(e.paymasterAndData),o=I([{type:"address"},{type:"uint256"},{type:"bytes32"},{type:"bytes32"},{type:"uint256"},{type:"uint256"},{type:"uint256"},{type:"uint256"},{type:"uint256"},{type:"bytes32"}],[e.sender,e.nonce,r,i,e.callGasLimit,e.verificationGasLimit,e.preVerificationGas,e.maxFeePerGas,e.maxPriorityFeePerGas,s]),u=I([{type:"bytes32"},{type:"address"},{type:"uint256"}],[b(o),t,BigInt(a)]);return b(u)}function Ze(n){return n.id==="smart"}const Z=new WeakMap,T=new WeakMap;async function et(n,e,t){const{personalAccount:a,client:r,chain:i}=e;if(!a)throw new Error("Personal wallet does not have an account");const s=t,o=s.factoryAddress??Ge,u=i??s.chain,c=M({client:r,address:o,chain:u}),p=await Ne(c,{personalAccountAddress:a.address,...s}).then(f=>f).catch(()=>{throw new Error(`Failed to get account address with factory contract ${c.address} on chain ID ${u.id}. Are you on the right chain?`)}),m=M({client:r,address:p,chain:u}),d="gasless"in s?s.gasless:s.sponsorGas,y=await Ke({...s,chain:u,sponsorGas:d,personalAccount:a,accountContract:m,factoryContract:c,client:r});return Z.set(a,n),T.set(n,a),[y,u]}async function tt(n){const e=T.get(n);e&&(Z.delete(e),T.delete(n))}async function Ke(n){const{accountContract:e}=n,t={address:e.address,async sendTransaction(a){const r=We({accountContract:e,options:n,transaction:a});return $({executeTx:r,options:n})},async sendBatchTransaction(a){const r=ke({accountContract:e,options:n,transactions:a});return $({executeTx:r,options:n})},async signMessage({message:a}){const[{isContractDeployed:r},{readContract:i},{encodeAbiParameters:s},{hashMessage:o},{checkContractWalletSignature:u}]=await Promise.all([g(()=>import("./index-B8mjO7EN.js").then(f=>f.f5),__vite__mapDeps([0,1])),g(()=>import("./index-B8mjO7EN.js").then(f=>f.fb),__vite__mapDeps([0,1])),g(()=>import("./index-B8mjO7EN.js").then(f=>f.fa),__vite__mapDeps([0,1])),g(()=>import("./index-B8mjO7EN.js").then(f=>f.f8),__vite__mapDeps([0,1])),g(()=>import("./checkContractWalletSignature-ieMwbFqd.js"),__vite__mapDeps([2,3,0,1]))]);await r(e)||(console.log("Account contract not deployed yet. Deploying account before signing message"),await F({options:n,account:t,accountContract:e}));const p=o(a);let m=!1;try{await i({contract:e,method:"function getMessageHash(bytes32 _hash) public view returns (bytes32)",params:[p]}),m=!0}catch{}let d;if(m){const f=s([{type:"bytes32"}],[p]);d=await n.personalAccount.signTypedData({domain:{name:"Account",version:"1",chainId:n.chain.id,verifyingContract:e.address},primaryType:"AccountMessage",types:{AccountMessage:[{name:"message",type:"bytes"}]},message:{message:f}})}else d=await n.personalAccount.signMessage({message:a});if(await u({contract:e,message:a,signature:d}))return d;throw new Error("Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.")},async signTypedData(a){var l,h,w;const r=Ee(a),[{isContractDeployed:i},{readContract:s},{encodeAbiParameters:o},{checkContractWalletSignedTypedData:u}]=await Promise.all([g(()=>import("./index-B8mjO7EN.js").then(v=>v.f5),__vite__mapDeps([0,1])),g(()=>import("./index-B8mjO7EN.js").then(v=>v.fb),__vite__mapDeps([0,1])),g(()=>import("./index-B8mjO7EN.js").then(v=>v.fa),__vite__mapDeps([0,1])),g(()=>import("./checkContractWalletSignedTypedData-CiThJyfu.js"),__vite__mapDeps([4,3,0,1]))]);if(((h=(l=r.domain)==null?void 0:l.verifyingContract)==null?void 0:h.toLowerCase())===((w=e.address)==null?void 0:w.toLowerCase()))return n.personalAccount.signTypedData(r);await i(e)||(console.log("Account contract not deployed yet. Deploying account before signing message"),await F({options:n,account:t,accountContract:e}));const m=xe(r);let d=!1;try{await s({contract:e,method:"function getMessageHash(bytes32 _hash) public view returns (bytes32)",params:[m]}),d=!0}catch{}let y;if(d){const v=o([{type:"bytes32"}],[m]);y=await n.personalAccount.signTypedData({domain:{name:"Account",version:"1",chainId:n.chain.id,verifyingContract:e.address},primaryType:"AccountMessage",types:{AccountMessage:[{name:"message",type:"bytes"}]},message:{message:v}})}else y=await n.personalAccount.signTypedData(r);if(await u({contract:e,data:r,signature:y}))return y;throw new Error("Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.")}};return t}async function F(n){const{options:e,account:t,accountContract:a}=n,[{sendTransaction:r},{prepareTransaction:i}]=await Promise.all([g(()=>import("./index-B8mjO7EN.js").then(u=>u.fc),__vite__mapDeps([0,1])),g(()=>import("./index-B8mjO7EN.js").then(u=>u.f9),__vite__mapDeps([0,1]))]),s=i({client:e.client,chain:e.chain,to:a.address,value:0n,gas:50000n});return await r({transaction:s,account:t})}async function $(n){const{executeTx:e,options:t}=n,a=await ze({executeTx:e,options:t}),r=await Je({options:t,userOp:a}),i=await Be({options:t,userOp:r}),s=await Qe({options:t,userOpHash:i});return{client:t.client,chain:t.chain,transactionHash:s.transactionHash}}async function Qe(n){const{options:e,userOpHash:t}=n,a=12e4,r=1e3,i=Date.now()+a;for(;Date.now()<i;){const s=await $e({options:e,userOpHash:t});if(s)return s;await new Promise(o=>setTimeout(o,r))}throw new Error("Timeout waiting for userOp to be mined")}export{et as connectSmartWallet,tt as disconnectSmartWallet,Ze as isSmartWallet,Z as personalAccountToSmartAccountMap};
