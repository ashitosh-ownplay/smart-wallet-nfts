const __vite__fileDeps=["assets/index-XQkpot5-.js","assets/index-B_SY1GJM.css","assets/checkContractWalletSignature-DQYDCIML.js","assets/isValidSignature-B1c3FlMq.js","assets/checkContractWalletSignedTypedData-BJ_w_xmb.js"],__vite__mapDeps=i=>i.map(i=>__vite__fileDeps[i]);
import{d as j,t as W,i as ie,a as oe,b as G,A as ce,c as ue,f as Z,e as Y,D as q,g as J,h as de,P as pe,j as D,s as le,B as me,k as M,l as ye,m as fe,n as ge,p as he,u as ve,o as L,r as b,q as we,v as K,w as Ae,x as h,y as be,z as X,C as xe,E,F as Pe,G as Q,H as ee,I as Te,J as w,M as _e,K as te,L as Ee,N as C,O as Ge,Q as De,R as Oe,S as Ie,T as Le,U as Ce,V as T,W as F,X as Se,_ as v,Y as ne,Z as Ue,$ as Me,a0 as B}from"./index-XQkpot5-.js";const Fe=j({id:324,name:"ZkSync Era",nativeCurrency:{decimals:18,name:"Ether",symbol:"ETH"},blockExplorers:[{name:"zkSync Era Block Explorer",url:"https://explorer.zksync.io",apiUrl:"https://block-explorer-api.zksync.dev/api"}]}),Be=j({id:300,name:"ZkSync Sepolia",nativeCurrency:{decimals:18,name:"Ether",symbol:"ETH"},blockExplorers:[{name:"zkSync Sepolia Block Explorer",url:"https://sepolia.explorer.zksync.io",apiUrl:"https://block-explorer-api.sepolia.zksync.dev/api"}]}),S=W;function He(e){const{abi:t,args:n=[],name:a}=e,s=ie(a,{strict:!1}),i=t.filter(o=>s?o.type==="function"?oe(o)===a:o.type==="event"?S(o)===a:!1:"name"in o&&o.name===a);if(i.length===0)return;if(i.length===1)return i[0];let r;for(const o of i){if(!("inputs"in o))continue;if(!n||n.length===0){if(!o.inputs||o.inputs.length===0)return o;continue}if(!o.inputs||o.inputs.length===0||o.inputs.length!==n.length)continue;if(n.every((u,p)=>{const l="inputs"in o&&o.inputs[p];return l?O(u,l):!1})){if(r&&"inputs"in r&&r.inputs){const u=ae(o.inputs,r.inputs,n);if(u)throw new ce({abiItem:o,type:u[0]},{abiItem:r,type:u[1]})}r=o}}return r||i[0]}function O(e,t){const n=typeof e,a=t.type;switch(a){case"address":return G(e,{strict:!1});case"bool":return n==="boolean";case"function":return n==="string";case"string":return n==="string";default:return a==="tuple"&&"components"in t?Object.values(t.components).every((s,i)=>O(Object.values(e)[i],s)):/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(a)?n==="number"||n==="bigint":/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(a)?n==="string"||e instanceof Uint8Array:/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(a)?Array.isArray(e)&&e.every(s=>O(s,{...t,type:a.replace(/(\[[0-9]{0,}\])$/,"")})):!1}}function ae(e,t,n){for(const a in e){const s=e[a],i=t[a];if(s.type==="tuple"&&i.type==="tuple"&&"components"in s&&"components"in i)return ae(s.components,i.components,n[a]);const r=[s.type,i.type];if(r.includes("address")&&r.includes("bytes20")?!0:r.includes("address")&&r.includes("string")?G(n[a],{strict:!1}):r.includes("address")&&r.includes("bytes")?G(n[a],{strict:!1}):!1)return r}}const H="/docs/contract/decodeEventLog";function ke(e){const{abi:t,data:n,strict:a,topics:s}=e,i=a??!0,[r,...o]=s;if(!r)throw new ue({docsPath:H});const c=t.find(m=>m.type==="event"&&r===S(Z(m)));if(!(c&&"name"in c)||c.type!=="event")throw new Y(r,{docsPath:H});const{name:u,inputs:p}=c,l=p==null?void 0:p.some(m=>!("name"in m&&m.name));let d=l?[]:{};const f=p.filter(m=>"indexed"in m&&m.indexed);for(let m=0;m<f.length;m++){const g=f[m],P=o[m];if(!P)throw new q({abiItem:c,param:g});d[l?m:g.name||m]=Re({param:g,value:P})}const y=p.filter(m=>!("indexed"in m&&m.indexed));if(y.length>0){if(n&&n!=="0x")try{const m=J(y,n);if(m)if(l)d=[...d,...m];else for(let g=0;g<y.length;g++)d[y[g].name]=m[g]}catch(m){if(i)throw m instanceof de||m instanceof pe?new D({abiItem:c,data:n,params:y,size:le(n)}):m}else if(i)throw new D({abiItem:c,data:"0x",params:y,size:0})}return{eventName:u,args:Object.values(d).length>0?d:void 0}}function Re({param:e,value:t}){return e.type==="string"||e.type==="bytes"||e.type==="tuple"||e.type.match(/^(.*)\[(\d+)?\]$/)?t:(J([e],t)||[])[0]}class Ve extends me{constructor(t){super(`Filter type "${t}" is not supported.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"FilterTypeNotSupportedError"})}}const k="/docs/contract/encodeEventTopics";function $e(e){var c;const{abi:t,eventName:n,args:a}=e;let s=t[0];if(n){const u=He({abi:t,name:n});if(!u)throw new M(n,{docsPath:k});s=u}if(s.type!=="event")throw new M(void 0,{docsPath:k});const i=Z(s),r=S(i);let o=[];if(a&&"inputs"in s){const u=(c=s.inputs)==null?void 0:c.filter(l=>"indexed"in l&&l.indexed),p=Array.isArray(a)?a:Object.values(a).length>0?(u==null?void 0:u.map(l=>a[l.name]))??[]:[];p.length>0&&(o=(u==null?void 0:u.map((l,d)=>Array.isArray(p[d])?p[d].map((f,y)=>R({param:l,value:p[d][y]})):p[d]?R({param:l,value:p[d]}):null))??[])}return[r,...o]}function R({param:e,value:t}){if(e.type==="string"||e.type==="bytes")return ye(fe(t));if(e.type==="tuple"||e.type.match(/^(.*)\[(\d+)?\]$/))throw new Ve(e.type);return ge([e],[t])}function Ne({abi:e,eventName:t,logs:n,strict:a=!0}){return n.map(s=>{var i;try{const r=ke({...s,abi:e,strict:a});return t&&!t.includes(r.eventName)?null:{...r,...s}}catch(r){let o,c;if(r instanceof Y)return null;if(r instanceof D||r instanceof q){if(a)return null;o=r.abiItem.name,c=(i=r.abiItem.inputs)==null?void 0:i.some(u=>!("name"in u&&u.name))}return{...s,args:c?[]:{},eventName:o}}}).filter(Boolean)}function ze(e){return!!(e&&typeof e=="object"&&"type"in e&&e.type==="event")}function je(e){const{signature:t}=e;let n;return ze(t)?n=t:n=he(t),{abiEvent:n,hash:W(n),topics:$e({abi:[n],args:e.filters})}}function We(e){const{logs:t,events:n,strict:a}=e;return Ne({logs:t,abi:n.map(s=>s.abiEvent),strict:a})}function Ze(e){return`0x${e.reduce((t,n)=>t+n.replace("0x",""),"")}`}function _(e){if(["string","number"].includes(typeof e)&&!Number.isInteger(Number(e)))throw new Error(`Expected value to be an integer to convert to a bigint, got ${e} of type ${typeof e}`);return e instanceof Uint8Array?BigInt(ve(e)):BigInt(e)}const se=50000n,Ye=e=>{const t=qe(e);return{domain:{name:"zkSync",version:"2",chainId:e.chainId},types:{Transaction:[{name:"txType",type:"uint256"},{name:"from",type:"uint256"},{name:"to",type:"uint256"},{name:"gasLimit",type:"uint256"},{name:"gasPerPubdataByteLimit",type:"uint256"},{name:"maxFeePerGas",type:"uint256"},{name:"maxPriorityFeePerGas",type:"uint256"},{name:"paymaster",type:"uint256"},{name:"nonce",type:"uint256"},{name:"value",type:"uint256"},{name:"data",type:"bytes"},{name:"factoryDeps",type:"bytes32[]"},{name:"paymasterInput",type:"bytes"}]},primaryType:"Transaction",message:t}};function qe(e){const{gas:t,nonce:n,to:a,from:s,value:i,maxFeePerGas:r,maxPriorityFeePerGas:o,paymaster:c,paymasterInput:u,gasPerPubdata:p,data:l}=e;return{txType:113n,from:BigInt(s),to:a?BigInt(a):0n,gasLimit:t??0n,gasPerPubdataByteLimit:p??se,maxFeePerGas:r??0n,maxPriorityFeePerGas:o??0n,paymaster:c?BigInt(c):0n,nonce:n?BigInt(n):0n,value:i??0n,data:l||"0x0",factoryDeps:[],paymasterInput:u||"0x"}}async function Je(e){const{account:t,eip712Transaction:n,chainId:a}=e,s=Ye(n),i=await t.signTypedData({...s});return Xe({...n,chainId:a,customSignature:i})}async function Ke(e){const{account:t,transaction:n}=e;let[a,s,i,r,o,c,u]=await Promise.all([L(n),b(n.to),b(n.value),b(n.gas),b(n.maxFeePerGas),b(n.maxPriorityFeePerGas),b(n.eip712).then(l=>l==null?void 0:l.gasPerPubdata)]);if(!r||!o||!c){const d=await we(n)({method:"zks_estimateFee",params:[{from:t.address,to:s,data:a,value:i?K(i):void 0}]});r=_(d.gas_limit),o=_(d.max_fee_per_gas)*2n,c=_(d.max_priority_fee_per_gas)||1n,u=_(d.gas_per_pubdata_limit)}return{...await Ae({transaction:{...n,gas:r,maxFeePerGas:o,maxPriorityFeePerGas:c},from:t.address}),...n.eip712,gasPerPubdata:u,from:t.address}}function Xe(e){const{chainId:t,gas:n,nonce:a,to:s,from:i,value:r,maxFeePerGas:o,maxPriorityFeePerGas:c,customSignature:u,factoryDeps:p,paymaster:l,paymasterInput:d,gasPerPubdata:f,data:y}=e,m=[a?h(a):"0x",c?h(c):"0x",o?h(o):"0x",n?h(n):"0x",s??"0x",r?h(r):"0x",y??"0x0",h(t),h(""),h(""),h(t),i??"0x",f?h(f):h(se),p??[],u??"0x",l&&d?[l,d]:[]];return Ze(["0x71",be(m)])}function Qe(e={}){return je({signature:"event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason)",filters:e})}const et=()=>{const e=BigInt(Math.floor(Math.random()*4294967296)),t=BigInt(Math.floor(Math.random()*4294967296)),n=BigInt(Math.floor(Math.random()*4294967296)),a=BigInt(Math.floor(Math.random()*4294967296)),s=BigInt(Math.floor(Math.random()*4294967296)),i=BigInt(Math.floor(Math.random()*4294967296));return e<<BigInt(160)|t<<BigInt(128)|n<<BigInt(96)|a<<BigInt(64)|s<<BigInt(32)|i},tt=()=>BigInt(X([K(et()),"0x0000000000000000"]));function U(e){return Object.fromEntries(Object.entries(e).map(([t,n])=>[t,xe(n)?n:h(n)]))}function nt(e){return e.id===Fe.id||e.id===Be.id}async function at(e){var t;return x({...e,operation:"eth_sendUserOperation",params:[U(e.userOp),((t=e.options.overrides)==null?void 0:t.entrypointAddress)??E]})}async function V(e){var n;const t=await x({...e,operation:"eth_estimateUserOperationGas",params:[U(e.userOp),((n=e.options.overrides)==null?void 0:n.entrypointAddress)??E]});return{preVerificationGas:w(t.preVerificationGas),verificationGas:w(t.verificationGas),verificationGasLimit:w(t.verificationGasLimit),callGasLimit:w(t.callGasLimit)+_e}}async function st(e){const t=await x({...e,operation:"thirdweb_getUserOperationGasPrice",params:[]});return{maxPriorityFeePerGas:w(t.maxPriorityFeePerGas),maxFeePerGas:w(t.maxFeePerGas)}}async function rt(e){var n,a;const t=await x({...e,operation:"eth_getUserOperationReceipt",params:[e.userOpHash]});if(t){if(t.success===!1){const i=(a=(n=We({events:[Qe()],logs:t.logs})[0])==null?void 0:n.args)==null?void 0:a.revertReason;if(!i)throw new Error(`UserOp failed at txHash: ${t.transactionHash}`);const r=Pe({data:i});throw new Error(`UserOp failed with reason: '${r.args.join(",")}' at txHash: ${t.transactionHash}`)}return t.receipt}}async function it(e){const t=await x({options:e.options,operation:"zk_paymasterData",params:[e.transaction]});return{paymaster:t.paymaster,paymasterInput:t.paymasterInput}}async function ot(e){return{transactionHash:(await x({options:e.options,operation:"zk_broadcastTransaction",params:[{...e.transaction,signedTransaction:e.signedTransaction}]})).transactionHash}}async function x(e){var c;const{options:t,operation:n,params:a}=e,s=((c=t.overrides)==null?void 0:c.bundlerUrl)??Q(t.chain),r=await ee(t.client)(s,{method:"POST",headers:{"Content-Type":"application/json"},body:Te({jsonrpc:"2.0",id:1,method:n,params:a})}),o=await r.json();if(!r.ok||o.error){let u=o.error||r.statusText;typeof u=="object"&&(u=JSON.stringify(u));const p=o.code||"UNKNOWN";throw new Error(`${n} error: ${u}
Status: ${r.status}
Code: ${p}`)}return o.result}async function ct(e,t){var s,i,r;if((s=t.overrides)!=null&&s.predictAddress)return t.overrides.predictAddress(e);if((i=t.overrides)!=null&&i.accountAddress)return t.overrides.accountAddress;const n=t.personalAccountAddress;if(!n)throw new Error("Account address is required to predict the smart wallet address.");const a=te(((r=t.overrides)==null?void 0:r.accountSalt)??"");return Ee({contract:e,method:"function getAddress(address, bytes) returns (address)",params:[n,a]})}function ut(e){var a,s;const{factoryContract:t,options:n}=e;return(a=n.overrides)!=null&&a.createAccount?n.overrides.createAccount(t):C({contract:t,method:"function createAccount(address, bytes) returns (address)",params:[n.personalAccount.address,te(((s=n.overrides)==null?void 0:s.accountSalt)??"")]})}function dt(e){var s;const{accountContract:t,options:n,transaction:a}=e;return(s=n.overrides)!=null&&s.execute?n.overrides.execute(t,a):C({contract:t,method:"function execute(address, uint256, bytes)",params:[a.to||"",a.value||0n,a.data||"0x"]})}function pt(e){var s;const{accountContract:t,options:n,transactions:a}=e;return(s=n.overrides)!=null&&s.executeBatch?n.overrides.executeBatch(t,a):C({contract:t,method:"function executeBatch(address[], uint256[], bytes[])",params:[a.map(i=>i.to||""),a.map(i=>i.value||0n),a.map(i=>i.data||"0x")]})}async function $(e){var l,d,f,y;const{userOp:t,options:n}=e;if((l=n.overrides)!=null&&l.paymaster)return(d=n.overrides)==null?void 0:d.paymaster(t);const a={"Content-Type":"application/json"},s=n.client,i=Ge(n.chain),r=((f=n.overrides)==null?void 0:f.entrypointAddress)??E,c=await ee(s)(i,{method:"POST",headers:a,body:JSON.stringify({jsonrpc:"2.0",id:1,method:"pm_sponsorUserOperation",params:[U(t),r]})}),u=await c.json();if(!c.ok){const m=u.error||c.statusText,g=u.code||"UNKNOWN";throw new Error(`Paymaster error: ${m}
Status: ${c.status}
Code: ${g}`)}if(u.result)return typeof u.result=="string"?{paymasterAndData:u.result}:{paymasterAndData:u.result.paymasterAndData,verificationGasLimit:u.result.verificationGasLimit?w(u.result.verificationGasLimit):void 0,preVerificationGas:u.result.preVerificationGas?w(u.result.preVerificationGas):void 0,callGasLimit:u.result.callGasLimit?w(u.result.callGasLimit):void 0};const p=((y=u.error)==null?void 0:y.message)||u.error||c.statusText||"unknown error";throw new Error(`Paymaster error from ${i}: ${p}`)}async function lt(e){var l;const{executeTx:t,options:n}=e,s=await De(n.accountContract)?"0x":await yt(n),i=await L(t);let{maxFeePerGas:r,maxPriorityFeePerGas:o}=t;const c=((l=n.overrides)==null?void 0:l.bundlerUrl)??Q(n.chain);if(Oe(c)){const d=await st({options:n});r=d.maxFeePerGas,o=d.maxPriorityFeePerGas}else{const[d,f]=await Promise.all([b(r),b(o)]);if(d&&f)r=d,o=f;else{const y=await Ie(n.client,n.chain);o=f??y.maxPriorityFeePerGas??0n,r=d??y.maxFeePerGas??0n}}const u=tt(),p={sender:n.accountContract.address,nonce:u,initCode:s,callData:i,maxFeePerGas:r,maxPriorityFeePerGas:o,callGasLimit:0n,verificationGasLimit:0n,preVerificationGas:0n,paymasterAndData:"0x",signature:Le};if(n.sponsorGas){const d=await $({userOp:p,options:n}),f=d.paymasterAndData;if(f&&f!=="0x"&&(p.paymasterAndData=f),d.callGasLimit&&d.verificationGasLimit&&d.preVerificationGas)p.callGasLimit=d.callGasLimit,p.verificationGasLimit=d.verificationGasLimit,p.preVerificationGas=d.preVerificationGas;else{const y=await V({userOp:p,options:n});if(p.callGasLimit=y.callGasLimit,p.verificationGasLimit=y.verificationGasLimit,p.preVerificationGas=y.preVerificationGas,f&&f!=="0x"){const m=await $({userOp:p,options:n});m.paymasterAndData&&m.paymasterAndData!=="0x"&&(p.paymasterAndData=m.paymasterAndData)}}}else{const d=await V({userOp:p,options:n});p.callGasLimit=d.callGasLimit,p.verificationGasLimit=d.verificationGasLimit,p.preVerificationGas=d.preVerificationGas}return{...p,signature:"0x"}}async function mt(e){var s;const{userOp:t,options:n}=e,a=ft({userOp:t,entryPoint:((s=n.overrides)==null?void 0:s.entrypointAddress)||E,chainId:n.chain.id});if(n.personalAccount.signMessage){const i=await n.personalAccount.signMessage({message:{raw:Ce(a)}});return{...t,signature:i}}throw new Error("signMessage not implemented in signingAccount")}async function yt(e){const{factoryContract:t}=e,n=ut({factoryContract:t,options:e});return X([t.address,await L(n)])}function ft(e){const{userOp:t,entryPoint:n,chainId:a}=e,s=T(t.initCode),i=T(t.callData),r=T(t.paymasterAndData),o=F([{type:"address"},{type:"uint256"},{type:"bytes32"},{type:"bytes32"},{type:"uint256"},{type:"uint256"},{type:"uint256"},{type:"uint256"},{type:"uint256"},{type:"bytes32"}],[t.sender,t.nonce,s,i,t.callGasLimit,t.verificationGasLimit,t.preVerificationGas,t.maxFeePerGas,t.maxPriorityFeePerGas,r]),c=F([{type:"bytes32"},{type:"address"},{type:"uint256"}],[T(o),n,BigInt(a)]);return T(c)}function At(e){return e.id==="smart"}const re=new WeakMap,I=new WeakMap;async function bt(e,t,n){const{personalAccount:a,client:s,chain:i}=t;if(!a)throw new Error("Personal wallet does not have an account");const r=n,o=r.factoryAddress??Se,c=i??r.chain,u="gasless"in r?r.gasless:r.sponsorGas;if(nt(c))return[ht({creationOptions:n,connectionOptions:t,chain:c,sponsorGas:u}),c];const p=B({client:s,address:o,chain:c}),l=await ct(p,{personalAccountAddress:a.address,...r}).then(y=>y).catch(y=>{throw new Error(`Failed to get account address with factory contract ${p.address} on chain ID ${c.id}. Are you on the right chain?`,{cause:y})}),d=B({client:s,address:l,chain:c}),f=await gt({...r,chain:c,sponsorGas:u,personalAccount:a,accountContract:d,factoryContract:p,client:s});return re.set(a,e),I.set(e,a),[f,c]}async function xt(e){const t=I.get(e);t&&(re.delete(t),I.delete(e))}async function gt(e){const{accountContract:t}=e,n={address:t.address,async sendTransaction(a){const s=dt({accountContract:t,options:e,transaction:a});return z({executeTx:s,options:e})},async sendBatchTransaction(a){const s=pt({accountContract:t,options:e,transactions:a});return z({executeTx:s,options:e})},async signMessage({message:a}){const[{isContractDeployed:s},{readContract:i},{encodeAbiParameters:r},{hashMessage:o},{checkContractWalletSignature:c}]=await Promise.all([v(()=>import("./index-XQkpot5-.js").then(y=>y.eT),__vite__mapDeps([0,1])),v(()=>import("./index-XQkpot5-.js").then(y=>y.eX),__vite__mapDeps([0,1])),v(()=>import("./index-XQkpot5-.js").then(y=>y.eW),__vite__mapDeps([0,1])),v(()=>import("./index-XQkpot5-.js").then(y=>y.eU),__vite__mapDeps([0,1])),v(()=>import("./checkContractWalletSignature-DQYDCIML.js"),__vite__mapDeps([2,3,0,1]))]);await s(t)||(console.log("Account contract not deployed yet. Deploying account before signing message"),await N({options:e,account:n,accountContract:t}));const p=o(a);let l=!1;try{await i({contract:t,method:"function getMessageHash(bytes32 _hash) public view returns (bytes32)",params:[p]}),l=!0}catch{}let d;if(l){const y=r([{type:"bytes32"}],[p]);d=await e.personalAccount.signTypedData({domain:{name:"Account",version:"1",chainId:e.chain.id,verifyingContract:t.address},primaryType:"AccountMessage",types:{AccountMessage:[{name:"message",type:"bytes"}]},message:{message:y}})}else d=await e.personalAccount.signMessage({message:a});if(await c({contract:t,message:a,signature:d}))return d;throw new Error("Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.")},async signTypedData(a){var m,g,P;const s=ne(a),[{isContractDeployed:i},{readContract:r},{encodeAbiParameters:o},{checkContractWalletSignedTypedData:c}]=await Promise.all([v(()=>import("./index-XQkpot5-.js").then(A=>A.eT),__vite__mapDeps([0,1])),v(()=>import("./index-XQkpot5-.js").then(A=>A.eX),__vite__mapDeps([0,1])),v(()=>import("./index-XQkpot5-.js").then(A=>A.eW),__vite__mapDeps([0,1])),v(()=>import("./checkContractWalletSignedTypedData-BJ_w_xmb.js"),__vite__mapDeps([4,3,0,1]))]);if(((g=(m=s.domain)==null?void 0:m.verifyingContract)==null?void 0:g.toLowerCase())===((P=t.address)==null?void 0:P.toLowerCase()))return e.personalAccount.signTypedData(s);await i(t)||(console.log("Account contract not deployed yet. Deploying account before signing message"),await N({options:e,account:n,accountContract:t}));const l=Ue(s);let d=!1;try{await r({contract:t,method:"function getMessageHash(bytes32 _hash) public view returns (bytes32)",params:[l]}),d=!0}catch{}let f;if(d){const A=o([{type:"bytes32"}],[l]);f=await e.personalAccount.signTypedData({domain:{name:"Account",version:"1",chainId:e.chain.id,verifyingContract:t.address},primaryType:"AccountMessage",types:{AccountMessage:[{name:"message",type:"bytes"}]},message:{message:A}})}else f=await e.personalAccount.signTypedData(s);if(await c({contract:t,data:s,signature:f}))return f;throw new Error("Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.")}};return n}function ht(e){const{creationOptions:t,connectionOptions:n,chain:a}=e,s={address:n.personalAccount.address,async sendTransaction(i){const r={data:i.data,to:i.to??void 0,value:i.value??0n,chain:Me(i.chainId),client:n.client};let o=await Ke({account:s,transaction:r});if(e.sponsorGas){const p=await it({options:{client:n.client,overrides:t.overrides,chain:a},transaction:o});o={...o,...p}}const c=await Je({account:s,chainId:a.id,eip712Transaction:o});return{transactionHash:(await ot({options:{client:n.client,overrides:t.overrides,chain:a},transaction:o,signedTransaction:c})).transactionHash,client:n.client,chain:a}},async signMessage({message:i}){return n.personalAccount.signMessage({message:i})},async signTypedData(i){const r=ne(i);return n.personalAccount.signTypedData(r)}};return s}async function N(e){const{options:t,account:n,accountContract:a}=e,[{sendTransaction:s},{prepareTransaction:i}]=await Promise.all([v(()=>import("./index-XQkpot5-.js").then(c=>c.eY),__vite__mapDeps([0,1])),v(()=>import("./index-XQkpot5-.js").then(c=>c.eV),__vite__mapDeps([0,1]))]),r=i({client:t.client,chain:t.chain,to:a.address,value:0n,gas:50000n});return await s({transaction:r,account:n})}async function z(e){const{executeTx:t,options:n}=e,a=await lt({executeTx:t,options:n}),s=await mt({options:n,userOp:a}),i=await at({options:n,userOp:s}),r=await vt({options:n,userOpHash:i});return{client:n.client,chain:n.chain,transactionHash:r.transactionHash}}async function vt(e){const{options:t,userOpHash:n}=e,a=12e4,s=1e3,i=Date.now()+a;for(;Date.now()<i;){const r=await rt({options:t,userOpHash:n});if(r)return r;await new Promise(o=>setTimeout(o,s))}throw new Error("Timeout waiting for userOp to be mined")}export{bt as connectSmartWallet,xt as disconnectSmartWallet,At as isSmartWallet,re as personalAccountToSmartAccountMap};
